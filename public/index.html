<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>OpenMind — Chat Console</title>
    <script src="https://cdn.jsdelivr.net/npm/ethers@6.15.0/dist/ethers.umd.min.js"></script>
    <style>
      :root {
        color-scheme: dark;
        --bg: #070a10;
        --bg2: #0b1020;
        --surface: rgba(255, 255, 255, 0.06);
        --surface-2: rgba(255, 255, 255, 0.04);
        --border: rgba(255, 255, 255, 0.12);
        --border-2: rgba(255, 255, 255, 0.08);
        --text: rgba(255, 255, 255, 0.92);
        --muted: rgba(255, 255, 255, 0.68);
        --muted-2: rgba(255, 255, 255, 0.52);
        --brand: #6ea8ff;
        --brand-2: #3b82f6;
        --danger: #ff4d6d;
        --shadow: 0 18px 60px rgba(0, 0, 0, 0.45);
        --radius: 16px;
        --radius-sm: 12px;
      }
      @media (prefers-color-scheme: light) {
        :root {
          color-scheme: light;
          --bg: #f7f7fb;
          --bg2: #ffffff;
          --surface: rgba(17, 24, 39, 0.04);
          --surface-2: rgba(17, 24, 39, 0.03);
          --border: rgba(17, 24, 39, 0.10);
          --border-2: rgba(17, 24, 39, 0.08);
          --text: rgba(17, 24, 39, 0.92);
          --muted: rgba(17, 24, 39, 0.66);
          --muted-2: rgba(17, 24, 39, 0.52);
          --brand: #2563eb;
          --brand-2: #1d4ed8;
          --danger: #e11d48;
          --shadow: 0 18px 60px rgba(17, 24, 39, 0.10);
        }
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto,
          Helvetica, Arial;
        background:
          radial-gradient(1200px 600px at 20% -10%, rgba(110, 168, 255, 0.25), transparent 55%),
          radial-gradient(900px 500px at 90% 10%, rgba(59, 130, 246, 0.18), transparent 60%),
          radial-gradient(900px 700px at 50% 100%, rgba(255, 77, 109, 0.10), transparent 55%),
          linear-gradient(180deg, var(--bg), var(--bg2));
        color: var(--text);
      }
      a {
        color: inherit;
        text-decoration: none;
      }
      code {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
        font-size: 0.95em;
        color: var(--text);
      }
      .wrap {
        max-width: 1080px;
        margin: 0 auto;
        padding: 24px 18px 56px;
      }
      .nav {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 10px 0 18px;
      }
      .brand {
        display: inline-flex;
        align-items: center;
        gap: 10px;
        font-weight: 800;
        letter-spacing: 0.2px;
      }
      .brand-mark {
        width: 26px;
        height: 26px;
        border-radius: 8px;
        background: linear-gradient(135deg, rgba(110, 168, 255, 1), rgba(59, 130, 246, 1));
        box-shadow: 0 10px 25px rgba(59, 130, 246, 0.25);
      }
      .nav-links {
        display: flex;
        gap: 12px;
        color: var(--muted);
        font-size: 13px;
      }
      .hero {
        padding: 10px 0 18px;
      }
      .title {
        font-size: 28px;
        font-weight: 850;
        letter-spacing: -0.02em;
        margin: 6px 0 8px;
      }
      .subtitle {
        color: var(--muted);
        line-height: 1.5;
        margin: 0 0 10px;
        max-width: 78ch;
      }
      .grid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 14px;
      }
      .card {
        background: linear-gradient(180deg, var(--surface), var(--surface-2));
        border: 1px solid var(--border);
        border-radius: var(--radius);
        padding: 16px;
        box-shadow: var(--shadow);
        backdrop-filter: blur(10px);
      }
      .card + .card {
        margin-top: 14px;
      }
      .card .title {
        font-size: 16px;
        margin: 0 0 6px;
        letter-spacing: -0.01em;
      }
      label {
        display: block;
        font-size: 12px;
        color: var(--muted);
        margin-bottom: 6px;
      }
      input,
      textarea,
      select {
        width: 100%;
        box-sizing: border-box;
        border: 1px solid var(--border-2);
        border-radius: var(--radius-sm);
        padding: 11px 12px;
        background: rgba(0, 0, 0, 0.12);
        color: var(--text);
        outline: none;
      }
      @media (prefers-color-scheme: light) {
        input,
        textarea,
        select {
          background: rgba(255, 255, 255, 0.7);
        }
      }
      input:focus,
      textarea:focus,
      select:focus {
        border-color: rgba(110, 168, 255, 0.55);
        box-shadow: 0 0 0 4px rgba(110, 168, 255, 0.16);
      }
      textarea {
        min-height: 110px;
        resize: vertical;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
        font-size: 12px;
        line-height: 1.4;
      }
      .row {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
      }
      .row.row-tight {
        grid-template-columns: 1fr auto;
        align-items: end;
      }
      .row.row-2 {
        grid-template-columns: 1fr 1fr;
      }
      @media (max-width: 860px) {
        .row {
          grid-template-columns: 1fr;
        }
        .title {
          font-size: 24px;
        }
        .nav-links {
          display: none;
        }
      }
      .btn {
        background: linear-gradient(135deg, var(--brand), var(--brand-2));
        color: rgba(255, 255, 255, 0.96);
        border: 0;
        border-radius: var(--radius-sm);
        padding: 11px 14px;
        font-weight: 800;
        cursor: pointer;
        box-shadow: 0 12px 30px rgba(59, 130, 246, 0.22);
      }
      .btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      .btn.secondary {
        background: transparent;
        border: 1px solid var(--border-2);
        color: var(--text);
        box-shadow: none;
      }
      .warn {
        color: var(--danger);
        font-size: 13px;
        line-height: 1.4;
      }
      pre {
        margin: 0;
        white-space: pre-wrap;
        word-break: break-word;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
        font-size: 12px;
        line-height: 1.45;
        color: var(--text);
        background: rgba(0, 0, 0, 0.14);
        border: 1px solid var(--border-2);
        border-radius: var(--radius-sm);
        padding: 10px 12px;
      }
      @media (prefers-color-scheme: light) {
        pre {
          background: rgba(255, 255, 255, 0.7);
        }
      }
      .hint {
        color: var(--muted-2);
        font-size: 12px;
        margin-top: 6px;
      }
      .kbd {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
        font-size: 11px;
        padding: 2px 6px;
        border-radius: 8px;
        border: 1px solid var(--border-2);
        color: var(--muted);
      }
      .mono {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
      }
      #chatLog,
      #wsLog {
        max-height: 680px;
        overflow: auto;
      }
      #chatLog {
        min-height: 420px;
      }
      .chat-input {
        min-height: 90px;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica,
          Arial;
        font-size: 14px;
        line-height: 1.45;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="nav">
        <div class="brand">
          <div class="brand-mark"></div>
          <div>测试机器人Openmind/USDC</div>
        </div>
        <div class="nav-links">
          <a href="https://openmind.org/" target="_blank" rel="noreferrer">Home</a>
          <span style="opacity:.55">/</span>
          <span>Chat Console</span>
          <span style="opacity:.55">/</span>
          <span class="kbd">Testnet</span>
        </div>
      </div>
      <div class="hero">
        <div class="title">Chat Console</div>
        <div class="subtitle">
          在同一个窗口里：聊天 → 工具调用 → 执行（本地 executor / chain-service）。建议优先用测试网，并把授权额度设置为小值。
        </div>
      </div>

      <div class="card" id="setupCard">
        <div class="row">
          <div>
            <label>OpenMind API Key（用户自己的）</label>
            <input
              id="apiKey"
              type="password"
              autocomplete="off"
              placeholder="om1_live_..."
            />
            <div class="hint">不会写入服务器存储；仅在本次请求中作为请求头发送。</div>
          </div>
          <div>
            <label>Model（可选）</label>
            <input id="model" placeholder="gpt-4.1-mini" value="gpt-4.1-mini" />
            <div class="hint">如果你的 OpenMind 账户支持其他模型，可自行改。</div>
          </div>
        </div>
      </div>

      <div id="chatDock"></div>

      <div class="card" id="x402Card">
        <div class="title">x402 钱包（沙盒演示，机器人侧托管）</div>
        <div class="subtitle" style="margin: 0 0 12px 0">
          说明：这里是“模拟 x402”的沙盒钱包与账本，钱包状态保存在 **线上 Vercel API**（同域 <span class="mono">/api/x402/*</span>）。
          不需要连接本地 executor / WebSocket。
        </div>

        <div class="row">
          <div>
            <label>授权开关（是否允许机器人发起支付）</label>
            <select id="x402Auth">
              <option value="off" selected>关闭（默认）</option>
              <option value="on">开启</option>
            </select>
            <div class="hint">关闭时点击“支付”会被拒绝（沙盒演示）。</div>
          </div>
          <div>
            <label>存储说明</label>
            <pre id="x402StorageHint">默认内存；可选接入 Vercel KV 持久化</pre>
          </div>
        </div>

        <div style="height: 12px"></div>
        <div class="row row-2">
          <button id="btnX402Refresh" class="btn secondary">刷新状态</button>
          <button id="btnX402Faucet" class="btn">沙盒充值（USDC）</button>
        </div>

        <div style="height: 10px"></div>
        <div class="row">
          <div>
            <label>充值数量（USDC）</label>
            <input id="x402FaucetAmount" value="10" />
          </div>
          <div>
            <label>状态</label>
            <pre id="x402StatusOut">未加载</pre>
          </div>
        </div>

        <div style="height: 12px"></div>
        <div class="row">
          <div>
            <label>支付对象（to）</label>
            <input id="x402PayTo" placeholder="例如：electricity / compute / user:alice / 0xabc..." />
          </div>
          <div>
            <label>支付金额（USDC）</label>
            <input id="x402PayAmount" value="1" />
          </div>
        </div>
        <div style="height: 10px"></div>
        <label>备注（memo，可选）</label>
        <input id="x402PayMemo" placeholder="例如：sandbox demo" />
        <div style="height: 12px"></div>
        <button id="btnX402Pay" class="btn">发起支付（沙盒）</button>

        <div style="height: 10px"></div>
        <label>结果</label>
        <pre id="x402ResultOut">-</pre>
      </div>

      <div class="card" id="walletCard">
        <div class="title" style="font-size: 16px; margin: 0 0 6px 0">
          钱包（MetaMask）一次授权：Approve USDC 给 Relayer（后续自动多笔）
        </div>
        <div class="subtitle" style="margin: 0 0 12px 0">
          这一步用的是“用户控钥”：私钥不进入前端代码、更不会上传到 Vercel。你只需要连接 MetaMask 并做一次 Approve（限额）。之后由本地 Relayer/Executor 代你多笔执行。
        </div>

        <div class="row">
          <div>
            <label>钱包状态</label>
            <pre id="walletStatus">未连接</pre>
          </div>
          <div>
            <label>网络配置（从 /api/public-config 读取）</label>
            <pre id="chainStatus">未加载</pre>
          </div>
        </div>

        <div style="height: 10px"></div>
        <div class="row">
          <button id="btnConnectWallet" class="btn">连接 MetaMask</button>
          <button id="btnSwitchChain" class="btn secondary">
            切换到 ARC Testnet
          </button>
        </div>

        <div style="height: 12px"></div>
        <div class="row">
          <div>
            <label>USDC 合约地址</label>
            <input id="usdcAddress" placeholder="0x..." />
          </div>
          <div>
            <label>Relayer 地址（spender）</label>
            <input id="relayerAddress" placeholder="0x...（你的本地 relayer 地址）" />
            <div class="hint">建议在 Vercel 环境变量里设置 RELAYER_ADDRESS，让这里自动填充。</div>
          </div>
        </div>

        <div style="height: 12px"></div>
        <div class="row">
          <div>
            <label>Approve 限额（USDC）</label>
            <input id="approveLimit" value="2" />
            <div class="hint">例如填 2，表示最多允许 relayer 总共花你 2 USDC（你可随时 revoke）。</div>
          </div>
          <div>
            <label>当前 Allowance（只读）</label>
            <pre id="allowanceOut">-</pre>
          </div>
        </div>

        <div style="height: 12px"></div>
        <div class="row">
          <button id="btnApprove" class="btn">发起 Approve</button>
          <button id="btnRefreshAllowance" class="btn secondary">
            刷新 Allowance
          </button>
        </div>
        <div class="warn" style="margin-top: 10px">
          注意：Approve 相当于授权额度。请只对你信任的 relayer 地址授权，测试网也建议设置小额度。
        </div>
      </div>

      <div class="card" id="robotWalletCard">
        <div class="title">机器人钱包（浏览器生成，仅测试用）</div>
        <div class="subtitle" style="margin: 0 0 12px 0">
          这个钱包由网页在你的浏览器本地生成并展示私钥/助记词。它不会自动有余额；你可以用下方按钮通过已连接的本地 executor（WS）让 relayer 给它打一点测试网主币（gas）或 USDC（如果 relayer 有余额）。
        </div>

        <div class="row row-2">
          <button id="btnRobotGenerate" class="btn">生成机器人钱包</button>
          <button id="btnRobotClear" class="btn secondary">清空</button>
        </div>

        <div style="height: 12px"></div>
        <label>机器人地址</label>
        <pre id="robotAddrOut">-</pre>
        <div style="height: 10px"></div>
        <div class="row row-tight">
          <button id="btnRobotCopyAddr" class="btn secondary">复制地址</button>
          <button id="btnRobotDownload" class="btn secondary">下载备份（JSON）</button>
        </div>

        <div style="height: 12px"></div>
        <label>私钥（敏感）</label>
        <pre id="robotPrivOut">-</pre>
        <div style="height: 10px"></div>
        <button id="btnRobotCopyPriv" class="btn secondary">复制私钥</button>

        <div style="height: 12px"></div>
        <label>助记词（如有）</label>
        <pre id="robotMnemonicOut">-</pre>

        <div class="warn" style="margin-top: 10px">
          注意：任何看到你屏幕/浏览器的人都可能拿到私钥。仅用于测试网；不要在主网或真实资产使用。
        </div>

        <div style="height: 14px"></div>
        <div class="row row-2">
          <div>
            <label>请求打 gas（ETH/主币）数量</label>
            <input id="robotGasAmount" value="0.01" />
            <div class="hint">
              会通过 WS 发送：<span class="mono">转 X ETH 到 0x...</span>，然后你再点“确认”。
            </div>
          </div>
          <div>
            <label>请求打 USDC 数量</label>
            <input id="robotUsdcAmount" value="1" />
            <div class="hint">
              会通过 WS 发送：<span class="mono">转 X USDC 到 0x...</span>（需要 relayer 有 USDC）。
            </div>
          </div>
        </div>
        <div style="height: 12px"></div>
        <div class="row row-2">
          <button id="btnRobotFundGas" class="btn">请求打 gas（走 WS）</button>
          <button id="btnRobotFundUsdc" class="btn secondary">请求打 USDC（走 WS）</button>
        </div>
      </div>

      <div class="card" id="chatCard">
        <label>对话框</label>
        <textarea id="userText" class="chat-input" placeholder="直接输入你想对机器人说的话（支持中文）&#10;例如：你好，介绍一下你能做什么"></textarea>
        <div style="height: 10px"></div>
        <div class="row row-tight">
          <div class="hint">提示：转账/链上执行目前仍建议走本地 WS（测试网）。纯聊天用 OpenMind 模式即可。</div>
          <button id="sendBtn" class="btn">发送</button>
        </div>
        <div style="height: 12px"></div>
        <label>聊天记录</label>
        <pre id="chatLog">尚未开始对话。</pre>
        <div style="height: 12px"></div>
        <div class="row">
          <div>
            <label>自动执行（测试网）</label>
            <select id="autoExecute">
              <option value="off" selected>关闭（推荐）</option>
              <option value="on">开启（收到 chain_execute 后自动执行）</option>
            </select>
            <div class="hint">开启后将跳过“确认执行”点击步骤，直接在对话里执行链上交易（仅建议测试网）。</div>
          </div>
          <div>
            <label>强制命令模式（JSON）</label>
            <select id="forceJson">
              <option value="on" selected>开启（建议）</option>
              <option value="off">关闭</option>
            </select>
            <div class="hint">开启时会请求模型返回 JSON（commands），便于自动执行。</div>
          </div>
        </div>
        <div style="height: 12px"></div>
        <div class="row">
          <div>
            <label>执行模式</label>
            <pre id="execMode">需要点击“确认执行（/api/execute）”</pre>
          </div>
          <div>
            <label>提示</label>
            <pre id="cmdHint">如果模型没有返回 commands，请让它“只输出 JSON commands”。</pre>
          </div>
        </div>
        <div style="height: 12px"></div>
        <div class="row">
          <div>
            <label>聊天执行通道</label>
            <select id="chatBackend">
              <option value="openmind" selected>AI（OpenMind，经 /api/dispatch）</option>
              <option value="ws">机器人直连（WS，可转账）</option>
            </select>
          </div>
        </div>
        <div id="wsInlineControls">
          <div style="height: 10px"></div>
          <div class="row">
            <div>
              <label>Executor WebSocket URL（用于 WS 模式）</label>
              <input id="wsUrlInline" placeholder="wss://xxxx.ngrok-free.app/ws" />
              <div class="hint">Vercel/https 页面必须用 wss://；本地可用 ws://127.0.0.1:8787/ws</div>
            </div>
            <div>
              <label>WS 连接</label>
              <div class="row row-2">
                <button id="wsConnectBtnInline" class="btn">连接</button>
                <button id="wsDisconnectBtnInline" class="btn secondary">断开</button>
              </div>
              <div class="hint">只在“机器人直连（WS）”模式下需要。</div>
            </div>
          </div>
        </div>
        <div style="height: 12px"></div>
        <div class="row row-2">
          <button id="btnChatConfirm" class="btn">确认</button>
          <button id="btnChatCancel" class="btn secondary">
            取消
          </button>
        </div>
        <div id="err" class="warn" style="margin-top: 10px; display: none"></div>
      </div>

      <div class="card" style="display:none">
        <div class="title" style="font-size: 16px; margin: 0 0 6px 0">
          机器人中文对话面板（连接本地 executor websocket）
        </div>
        <div class="subtitle" style="margin: 0 0 12px 0">
          这里直接连到你本地 executor 的 <code>WS /ws</code>，支持中文指令（转账 + 确认/取消）。
          如果你在 Vercel（https）打开本页面，浏览器会阻止 <code>ws://</code>，请用
          <code>wss://</code>（例如 ngrok 的 wss 地址）。
          <div class="warn" style="margin-top: 8px">
            提醒：不要把 executor 的 /ws 长期暴露给公网；这是调试通道。
          </div>
        </div>

        <label>Executor WebSocket URL</label>
        <input
          id="wsUrl"
          placeholder="wss://xxxx.ngrok-free.app/ws"
          value=""
        />
        <div class="hint">
          本地打开可用：<code>ws://127.0.0.1:8787/ws</code>；Vercel/https 页面请用 wss。
        </div>
        <div style="height: 10px"></div>
        <button id="wsConnectBtn" class="btn">连接</button>
        <button id="wsDisconnectBtn" class="btn" style="background: transparent; border: 1px solid var(--border); color: var(--text); margin-left: 8px">
          断开
        </button>
        <div style="height: 12px"></div>

        <label>对话日志（WebSocket）</label>
        <pre id="wsLog">未连接。</pre>
        <div style="height: 12px"></div>

        <label>发送消息（中文指令或普通文本）</label>
        <div class="row">
          <input id="wsMsg" placeholder="例如：转 1.23 USDC 到 0x..." />
          <button id="wsSendBtn" class="btn">发送</button>
        </div>
        <div class="hint">快捷：发送后如收到确认提示，请回复“确认”或“取消”。</div>

        <div style="height: 12px"></div>
        <div class="row">
          <button id="btnConfirmExecute" class="btn">确认执行（/api/execute）</button>
          <button id="btnWsConfirm" class="btn">确认（WS）</button>
          <button id="btnCancel" class="btn secondary">
            取消
          </button>
        </div>
      </div>
    </div>

    <script>
      const $ = (id) => document.getElementById(id);
      // Dock the main chat card under setupCard to make it the primary focus.
      const chatDock = document.getElementById("chatDock");
      const chatCard = document.getElementById("chatCard");
      if (chatDock && chatCard) chatDock.appendChild(chatCard);

      const chatLog = $("chatLog");
      const err = $("err");
      const btn = $("sendBtn");
      const wsInlineControls = document.getElementById("wsInlineControls");

      const wsLog = $("wsLog");
      const wsUrl = $("wsUrl");
      const wsConnectBtn = $("wsConnectBtn");
      const wsDisconnectBtn = $("wsDisconnectBtn");
      const wsSendBtn = $("wsSendBtn");
      const wsMsg = $("wsMsg");
      const btnConfirmExecute = $("btnConfirmExecute");
      const btnWsConfirm = $("btnWsConfirm");
      const btnCancel = $("btnCancel");

      const walletStatus = $("walletStatus");
      const chainStatus = $("chainStatus");
      const btnConnectWallet = $("btnConnectWallet");
      const btnSwitchChain = $("btnSwitchChain");
      const usdcAddressEl = $("usdcAddress");
      const relayerAddressEl = $("relayerAddress");
      const approveLimitEl = $("approveLimit");
      const allowanceOut = $("allowanceOut");
      const btnApprove = $("btnApprove");
      const btnRefreshAllowance = $("btnRefreshAllowance");
      const autoExecuteSel = $("autoExecute");
      const forceJsonSel = $("forceJson");
      const execMode = $("execMode");
      const cmdHint = $("cmdHint");
      const chatBackend = $("chatBackend");
      const wsUrlInline = $("wsUrlInline");
      const wsConnectBtnInline = $("wsConnectBtnInline");
      const wsDisconnectBtnInline = $("wsDisconnectBtnInline");
      const btnChatConfirm = $("btnChatConfirm");
      const btnChatCancel = $("btnChatCancel");
      const btnRobotGenerate = $("btnRobotGenerate");
      const btnRobotClear = $("btnRobotClear");
      const robotAddrOut = $("robotAddrOut");
      const robotPrivOut = $("robotPrivOut");
      const robotMnemonicOut = $("robotMnemonicOut");
      const btnRobotCopyAddr = $("btnRobotCopyAddr");
      const btnRobotCopyPriv = $("btnRobotCopyPriv");
      const btnRobotDownload = $("btnRobotDownload");
      const robotGasAmount = $("robotGasAmount");
      const robotUsdcAmount = $("robotUsdcAmount");
      const btnRobotFundGas = $("btnRobotFundGas");
      const btnRobotFundUsdc = $("btnRobotFundUsdc");
      const x402Auth = $("x402Auth");
      const btnX402Refresh = $("btnX402Refresh");
      const btnX402Faucet = $("btnX402Faucet");
      const x402FaucetAmount = $("x402FaucetAmount");
      const x402StatusOut = $("x402StatusOut");
      const x402PayTo = $("x402PayTo");
      const x402PayAmount = $("x402PayAmount");
      const x402PayMemo = $("x402PayMemo");
      const btnX402Pay = $("btnX402Pay");
      const x402ResultOut = $("x402ResultOut");
      const x402StorageHint = $("x402StorageHint");

      let sock = null;
      let lastOpenMindPayloadForExecutor = null; // used for confirm-to-execute
      let lastCommands = null;
      let publicCfg = null;
      let walletProvider = null;
      let signer = null;
      let walletAddress = "";
      let robotWallet = null;

      async function x402Fetch(path, opts) {
        const url = "/api" + path;
        const r = await fetch(url, {
          method: (opts && opts.method) || "GET",
          headers: {
            "content-type": "application/json",
            ...((opts && opts.headers) || {}),
          },
          body: opts && opts.body ? JSON.stringify(opts.body) : undefined,
        });
        const t = await r.text();
        let data = null;
        try {
          data = JSON.parse(t);
        } catch {
          data = { raw: t };
        }
        if (!r.ok) {
          const msg =
            (data && (data.detail || data.error || data.message)) ||
            `HTTP ${r.status}`;
          throw new Error(String(msg));
        }
        return data;
      }

      async function refreshX402Status() {
        try {
          const s = await x402Fetch("/x402/status");
          if (x402StatusOut) x402StatusOut.textContent = JSON.stringify(s, null, 2);
          if (x402Auth && s?.wallet) x402Auth.value = s.wallet.auth_enabled ? "on" : "off";
          if (x402StorageHint && s?.storage) {
            x402StorageHint.textContent =
              s.storage === "kv"
                ? "已启用 Vercel KV（持久化）"
                : "未启用 KV：当前为内存（冷启动会重置）";
          }
          if (x402ResultOut) x402ResultOut.textContent = "-";
          setError("");
        } catch (e) {
          setError("x402 状态获取失败：" + String(e?.message || e));
        }
      }

      btnX402Refresh?.addEventListener("click", refreshX402Status);
      x402Auth?.addEventListener("change", async () => {
        try {
          const enabled = x402Auth.value === "on";
          const r = await x402Fetch("/x402/authorize", {
            method: "POST",
            body: { enabled },
          });
          if (x402ResultOut) x402ResultOut.textContent = JSON.stringify(r, null, 2);
          await refreshX402Status();
          setError("");
        } catch (e) {
          setError("x402 授权设置失败：" + String(e?.message || e));
        }
      });
      btnX402Faucet?.addEventListener("click", async () => {
        try {
          const amt = String(x402FaucetAmount?.value || "10").trim() || "10";
          const r = await x402Fetch("/x402/faucet", {
            method: "POST",
            body: { amount_usdc: amt },
          });
          if (x402ResultOut) x402ResultOut.textContent = JSON.stringify(r, null, 2);
          await refreshX402Status();
          setError("");
        } catch (e) {
          setError("x402 充值失败：" + String(e?.message || e));
        }
      });
      btnX402Pay?.addEventListener("click", async () => {
        try {
          const to = String(x402PayTo?.value || "").trim();
          const amt = String(x402PayAmount?.value || "1").trim() || "1";
          const memo = String(x402PayMemo?.value || "").trim();
          if (!to) return setError("请填写支付对象（to）。");
          const r = await x402Fetch("/x402/pay", {
            method: "POST",
            body: { to, amount_usdc: amt, memo },
          });
          if (x402ResultOut) x402ResultOut.textContent = JSON.stringify(r, null, 2);
          await refreshX402Status();
          setError("");
        } catch (e) {
          setError("x402 支付失败：" + String(e?.message || e));
        }
      });

      // Load status on startup (best effort)
      refreshX402Status();

      function setRobotWallet(w) {
        robotWallet = w;
        if (!w) {
          robotAddrOut.textContent = "-";
          robotPrivOut.textContent = "-";
          robotMnemonicOut.textContent = "-";
          return;
        }
        robotAddrOut.textContent = w.address || "-";
        robotPrivOut.textContent = w.privateKey || "-";
        const phrase = w?.mnemonic?.phrase || "";
        robotMnemonicOut.textContent = phrase || "-";
      }

      async function copyText(s) {
        const text = String(s || "");
        if (!text) return;
        try {
          await navigator.clipboard.writeText(text);
        } catch {
          const ta = document.createElement("textarea");
          ta.value = text;
          document.body.appendChild(ta);
          ta.select();
          document.execCommand("copy");
          document.body.removeChild(ta);
        }
      }

      function downloadJson(filename, obj) {
        const blob = new Blob([JSON.stringify(obj, null, 2)], {
          type: "application/json",
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      function updateExecMode() {
        const on = autoExecuteSel.value === "on";
        execMode.textContent = on
          ? "自动执行：收到 chain_execute 后会自动调用 /api/execute"
          : "需要点击“确认执行（/api/execute）”";
      }
      autoExecuteSel.addEventListener("change", updateExecMode);
      updateExecMode();

      function setError(message) {
        if (!message) {
          err.style.display = "none";
          err.textContent = "";
          return;
        }
        err.style.display = "block";
        err.textContent = message;
      }

      function updateChatBackendUI() {
        const isWs = chatBackend && chatBackend.value === "ws";
        if (wsInlineControls) wsInlineControls.style.display = isWs ? "block" : "none";
      }
      if (chatBackend) chatBackend.addEventListener("change", updateChatBackendUI);
      updateChatBackendUI();

      // ---- Robot wallet (browser generated) ----
      btnRobotGenerate?.addEventListener("click", () => {
        try {
          const w = ethers.Wallet.createRandom();
          setRobotWallet(w);
          setError("");
          if (chatLog.textContent === "尚未开始对话。") chatLog.textContent = "";
          chatLog.textContent += `\n[ui] 已生成机器人钱包：${w.address}`;
        } catch (e) {
          setError("生成钱包失败：" + String(e));
        }
      });
      btnRobotClear?.addEventListener("click", () => {
        setRobotWallet(null);
        setError("");
      });
      btnRobotCopyAddr?.addEventListener("click", async () => {
        if (!robotWallet?.address) return setError("请先生成机器人钱包。");
        await copyText(robotWallet.address);
        setError("");
      });
      btnRobotCopyPriv?.addEventListener("click", async () => {
        if (!robotWallet?.privateKey) return setError("请先生成机器人钱包。");
        await copyText(robotWallet.privateKey);
        setError("");
      });
      btnRobotDownload?.addEventListener("click", () => {
        if (!robotWallet?.address || !robotWallet?.privateKey)
          return setError("请先生成机器人钱包。");
        const payload = {
          address: robotWallet.address,
          private_key: robotWallet.privateKey,
          mnemonic: robotWallet?.mnemonic?.phrase || null,
          created_at: new Date().toISOString(),
          note: "Testnet only. Keep private_key safe. Do NOT use on mainnet.",
        };
        downloadJson(`robot-wallet-${robotWallet.address}.json`, payload);
        setError("");
      });

      function ensureWsConnectedForFunding() {
        if (!sock || sock.readyState !== WebSocket.OPEN) {
          setError("请先连接机器人（WS），再执行打款。");
          return false;
        }
        if (chatBackend) chatBackend.value = "ws";
        return true;
      }

      btnRobotFundGas?.addEventListener("click", () => {
        if (!robotWallet?.address) return setError("请先生成机器人钱包。");
        if (!ensureWsConnectedForFunding()) return;
        const amt = String(robotGasAmount?.value || "0.01").trim() || "0.01";
        const text = `转 ${amt} ETH 到 ${robotWallet.address}`;
        if (chatLog.textContent === "尚未开始对话。") chatLog.textContent = "";
        chatLog.textContent += (chatLog.textContent ? "\n" : "") + `[我] ${text}`;
        sendWs(text);
        setError("");
      });
      btnRobotFundUsdc?.addEventListener("click", () => {
        if (!robotWallet?.address) return setError("请先生成机器人钱包。");
        if (!ensureWsConnectedForFunding()) return;
        const amt = String(robotUsdcAmount?.value || "1").trim() || "1";
        const text = `转 ${amt} USDC 到 ${robotWallet.address}`;
        if (chatLog.textContent === "尚未开始对话。") chatLog.textContent = "";
        chatLog.textContent += (chatLog.textContent ? "\n" : "") + `[我] ${text}`;
        sendWs(text);
        setError("");
      });

      function logLine(line) {
        const current = wsLog.textContent || "";
        const next = current === "未连接。" ? "" : current;
        wsLog.textContent = (next ? next + "\n" : "") + line;
      }

      function tryDefaultWsUrl() {
        // If running locally (http), default to ws://localhost.
        if (location.hostname === "localhost" || location.hostname === "127.0.0.1") {
          return "ws://127.0.0.1:8787/ws";
        }
        // Otherwise leave empty; user should paste wss:// from their tunnel (ngrok/cloudflare).
        return "";
      }

      wsUrl.value = tryDefaultWsUrl();
      if (wsUrlInline) wsUrlInline.value = wsUrl.value;

      function normalizeWsUrl(input) {
        let u = (input || "").trim();
        if (!u) return "";

        // Allow user to paste:
        // - a4dac...ngrok-free.app
        // - https://a4dac...ngrok-free.app
        // - wss://a4dac...ngrok-free.app/ws
        // - ws://127.0.0.1:8787/ws
        if (u.startsWith("http://")) u = "ws://" + u.slice("http://".length);
        if (u.startsWith("https://")) u = "wss://" + u.slice("https://".length);

        const hasScheme = u.startsWith("ws://") || u.startsWith("wss://");
        if (!hasScheme) {
          const local =
            location.hostname === "localhost" || location.hostname === "127.0.0.1";
          u = (local ? "ws://" : "wss://") + u;
        }

        // Ensure it ends with /ws (unless user explicitly provided a path).
        try {
          const parsed = new URL(u);
          if (!parsed.pathname || parsed.pathname === "/") parsed.pathname = "/ws";
          return parsed.toString();
        } catch {
          // Fallback: append /ws if missing
          if (!u.includes("/")) return u + "/ws";
          if (u.endsWith("/")) return u + "ws";
          if (!u.endsWith("/ws")) return u + "/ws";
          return u;
        }
      }

      function connectWs() {
        const url = normalizeWsUrl((wsUrlInline && wsUrlInline.value) || wsUrl.value);
        if (!url) {
          logLine("[ui] 请先填写 Executor WebSocket URL（例如 wss://xxxx.ngrok-free.app/ws）。");
          return;
        }
        if (sock) {
          logLine("[ui] 已连接或正在连接，请先断开。");
          return;
        }
        try {
          sock = new WebSocket(url);
        } catch (e) {
          sock = null;
          logLine("[ui] WebSocket 创建失败：" + String(e));
          return;
        }

        logLine("[ui] connecting… " + url);
        sock.onopen = () => logLine("[ws] connected");
        sock.onclose = () => {
          logLine("[ws] closed");
          sock = null;
        };
        sock.onerror = (e) => logLine("[ws] error: " + JSON.stringify(e));
        sock.onmessage = (ev) => {
          const raw = String(ev.data ?? "");
          let obj = null;
          try { obj = JSON.parse(raw); } catch {}
          if (obj && obj.type === "chain_result") {
            // Best-effort link to arcscan if tx_hash exists
            const tx = obj?.result?.data?.tx_hash || obj?.result?.data?.data?.tx_hash;
            logLine("[robot] " + JSON.stringify(obj, null, 2));
            if (tx) logLine("[robot] tx_hash: " + tx + " (打开 testnet.arcscan.app 查询)");
            if (chatLog.textContent === "尚未开始对话。") chatLog.textContent = "";
            chatLog.textContent += `\n[机器人] ${JSON.stringify(obj)}`;
            return;
          }
          logLine("[robot] " + (obj ? JSON.stringify(obj, null, 2) : raw));
          if (chatLog.textContent === "尚未开始对话。") chatLog.textContent = "";
          chatLog.textContent += `\n[机器人] ${obj ? JSON.stringify(obj) : raw}`;
        };
      }

      function disconnectWs() {
        if (!sock) {
          logLine("[ui] 未连接。");
          return;
        }
        sock.close();
      }

      function sendWs(text) {
        if (!sock || sock.readyState !== WebSocket.OPEN) {
          logLine("[ui] 未连接 websocket。");
          setError("你选择了“机器人直连（WS）”模式，但还没连接 WS。请先连接，或切换到 OpenMind 模式。");
          return;
        }
        sock.send(text);
        logLine("[me] " + text);
      }

      async function send() {
        setError("");
        const apiKey = $("apiKey").value.trim();
        const model = $("model").value.trim() || "gpt-4.1-mini";
        let system = "你是一个有帮助的中文机器人助手。";
        const userText = $("userText").value.trim();

        if (!userText) return setError("请填写用户输入文本。");

        // WS mode: send directly to executor websocket (this is the path that reliably supports transfers)
        if (chatBackend && chatBackend.value === "ws") {
          if (chatLog.textContent === "尚未开始对话。") chatLog.textContent = "";
          chatLog.textContent += (chatLog.textContent ? "\n" : "") + `[我] ${userText}`;
          sendWs(userText);
          return;
        }

        // OpenMind mode requires API key
        if (!apiKey) return setError("请填写 OpenMind API Key。");

        // If wallet connected, provide context so the model outputs allowance-based commands.
        // This keeps keys user-controlled and enables relayer transferFrom after approve.
        const relayer = (relayerAddressEl.value || "").trim();
        const usdc = (usdcAddressEl.value || "").trim();
        if (walletAddress && relayer && usdc) {
          system +=
            `\n\n[Onchain tool instructions]\n` +
            `- The user's wallet address is ${walletAddress}.\n` +
            `- USDC token_address is ${usdc} (decimals=6) on chain_id ${publicCfg?.chain_id || 5042002}.\n` +
            `- Relayer address (spender) is ${relayer}. The user will approve allowance to this relayer.\n` +
            `- If the user asks to send USDC, output commands with type="chain_execute" and value using type="transfer_from_erc20" with fields: {token_address, from, to, amount, decimals:6, expected_chain_id}.\n` +
            `- For multiple payments, set value.times=N.\n` +
            `- Do not include private keys.\n`;
        }

        btn.disabled = true;
        btn.textContent = "发送中…";

        if (chatLog.textContent === "尚未开始对话。") chatLog.textContent = "";
        chatLog.textContent += (chatLog.textContent ? "\n" : "") + `[我] ${userText}`;

        const payload = {
          openmind: {
            body: {
              model,
              messages: [
                { role: "system", content: system },
                { role: "user", content: userText },
              ],
              ...(forceJsonSel.value === "on"
                ? {
                    // OpenAI-compatible hint to return JSON object. If unsupported, it should be ignored.
                    response_format: { type: "json_object" },
                  }
                : {}),
            },
          },
          // Do NOT auto-forward before user confirms. We'll call /api/execute after confirmation.
          forward_to_executor: false,
        };

        try {
          const r = await fetch("/api/dispatch", {
            method: "POST",
            headers: {
              "content-type": "application/json",
              authorization: `Bearer ${apiKey}`,
            },
            body: JSON.stringify(payload),
          });

          const text = await r.text();
          let data;
          try {
            data = JSON.parse(text);
          } catch {
            data = { raw: text };
          }

          // Display assistant content if present
          let assistant = "";
          try {
            assistant = data?.openmind_response?.choices?.[0]?.message?.content || "";
          } catch {}
          if (assistant) chatLog.textContent += `\n[助手] ${assistant}`;
          else chatLog.textContent += `\n[助手] （已返回 OpenMind 响应，但未找到 message.content）`;

          // Store for confirm-to-execute
          lastOpenMindPayloadForExecutor = {
            openmind_status: data?.openmind_status,
            openmind_response: data?.openmind_response,
          };

          // Try to extract commands (best effort)
          lastCommands = data?.openmind_response?.commands || null;
          let contentCommands = null;
          if (!Array.isArray(lastCommands) && assistant) {
            try {
              const parsed = JSON.parse(assistant.trim());
              if (Array.isArray(parsed)) contentCommands = parsed;
              else if (parsed && typeof parsed === "object" && Array.isArray(parsed.commands)) contentCommands = parsed.commands;
            } catch {}
          }
          const cmds = Array.isArray(lastCommands) ? lastCommands : Array.isArray(contentCommands) ? contentCommands : null;
          if (cmds && cmds.length) {
            chatLog.textContent += `\n[系统] 检测到 commands：${JSON.stringify(cmds)}`;
            chatLog.textContent += `\n[系统] ${autoExecuteSel.value === "on" ? "将自动执行…" : "请点击“确认执行（/api/execute）”执行。"} `;

            // Auto-execute (testnet) if enabled
            if (autoExecuteSel.value === "on") {
              try {
                const r2 = await fetch("/api/execute", {
                  method: "POST",
                  headers: { "content-type": "application/json" },
                  body: JSON.stringify({ payload: lastOpenMindPayloadForExecutor }),
                });
                const t2 = await r2.text();
                let d2;
                try { d2 = JSON.parse(t2); } catch { d2 = { raw: t2 }; }
                chatLog.textContent += `\n[执行结果] ${JSON.stringify(d2)}`;
              } catch (e2) {
                chatLog.textContent += `\n[执行结果] 失败：${String(e2)}`;
              }
            }
          } else {
            cmdHint.textContent =
              "模型未返回 commands。你可以再发一句：请只输出 JSON（{\"commands\":[...] }），不要解释。";
          }
        } catch (e) {
          setError(String(e));
          chatLog.textContent += `\n[系统] 请求失败：${String(e)}`;
        } finally {
          btn.disabled = false;
          btn.textContent = "发送";
        }
      }

      btn.addEventListener("click", send);
      $("userText").addEventListener("keydown", (e) => {
        if ((e.ctrlKey || e.metaKey) && e.key === "Enter") send();
      });

      // Confirm-to-execute from the same window
      btnConfirmExecute.addEventListener("click", async () => {
        if (!lastOpenMindPayloadForExecutor) {
          logLine("[ui] 没有可执行的 payload（请先发送一条消息）。");
          return;
        }
        logLine("[ui] 正在确认执行（调用 /api/execute）…");
        try {
          const r = await fetch("/api/execute", {
            method: "POST",
            headers: { "content-type": "application/json" },
            body: JSON.stringify({ payload: lastOpenMindPayloadForExecutor }),
          });
          const text = await r.text();
          let data;
          try { data = JSON.parse(text); } catch { data = { raw: text }; }
          chatLog.textContent += `\n[执行结果] ${JSON.stringify(data)}`;
        } catch (e) {
          chatLog.textContent += `\n[执行结果] 失败：${String(e)}`;
        }
      });

      wsConnectBtn.addEventListener("click", connectWs);
      wsDisconnectBtn.addEventListener("click", disconnectWs);
      wsSendBtn.addEventListener("click", () => sendWs(wsMsg.value.trim()));
      wsMsg.addEventListener("keydown", (e) => {
        if (e.key === "Enter") sendWs(wsMsg.value.trim());
      });
      btnWsConfirm.addEventListener("click", () => sendWs("确认"));
      btnCancel.addEventListener("click", () => sendWs("取消"));

      // Inline WS controls (single chat)
      if (wsConnectBtnInline) wsConnectBtnInline.addEventListener("click", connectWs);
      if (wsDisconnectBtnInline) wsDisconnectBtnInline.addEventListener("click", disconnectWs);

      // Single chat confirm/cancel buttons
      if (btnChatConfirm)
        btnChatConfirm.addEventListener("click", () => {
          if (chatBackend && chatBackend.value === "ws") return sendWs("确认");
          return btnConfirmExecute.click();
        });
      if (btnChatCancel)
        btnChatCancel.addEventListener("click", () => {
          if (chatBackend && chatBackend.value === "ws") return sendWs("取消");
        });

      // ---- MetaMask + Approve flow (Allowance-based MVP) ----
      async function loadPublicConfig() {
        try {
          const r = await fetch("/api/public-config");
          const cfg = await r.json();
          publicCfg = cfg;
          chainStatus.textContent = JSON.stringify(cfg, null, 2);
          if (!usdcAddressEl.value) usdcAddressEl.value = cfg.usdc_address || "";
          if (!relayerAddressEl.value) relayerAddressEl.value = cfg.relayer_address || "";
        } catch (e) {
          chainStatus.textContent = "加载失败: " + String(e);
        }
      }

      function hexChainId(n) {
        return "0x" + Number(n).toString(16);
      }

      async function connectWallet() {
        if (!window.ethereum) {
          walletStatus.textContent = "未检测到 MetaMask（window.ethereum 不存在）";
          return;
        }
        try {
          walletProvider = new ethers.BrowserProvider(window.ethereum);
          await walletProvider.send("eth_requestAccounts", []);
          signer = await walletProvider.getSigner();
          walletAddress = await signer.getAddress();
          const net = await walletProvider.getNetwork();
          walletStatus.textContent = JSON.stringify(
            { connected: true, address: walletAddress, chain_id: Number(net.chainId) },
            null,
            2
          );
        } catch (e) {
          walletStatus.textContent = "连接失败: " + String(e);
        }
      }

      async function switchToArcTestnet() {
        if (!window.ethereum) return;
        const cfg = publicCfg || {};
        const chainId = Number(cfg.chain_id || 5042002);
        const rpcUrl = String(cfg.rpc_url || "https://rpc.testnet.arc.network");
        const explorer = String(cfg.explorer_url || "https://testnet.arcscan.app");
        try {
          await window.ethereum.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: hexChainId(chainId) }],
          });
        } catch (e) {
          // If not added, try add
          try {
            await window.ethereum.request({
              method: "wallet_addEthereumChain",
              params: [
                {
                  chainId: hexChainId(chainId),
                  chainName: "ARC Testnet",
                  rpcUrls: [rpcUrl],
                  blockExplorerUrls: [explorer],
                  nativeCurrency: { name: "ARC", symbol: "ARC", decimals: 18 },
                },
              ],
            });
          } catch (e2) {
            walletStatus.textContent = "切换网络失败: " + String(e2);
          }
        }
      }

      async function refreshAllowance() {
        try {
          if (!walletProvider || !signer) {
            allowanceOut.textContent = "请先连接钱包";
            return;
          }
          const owner = walletAddress || (await signer.getAddress());
          const usdc = usdcAddressEl.value.trim();
          const relayer = relayerAddressEl.value.trim();
          if (!usdc || !relayer) {
            allowanceOut.textContent = "请填写 USDC 地址与 Relayer 地址";
            return;
          }
          const abi = ["function allowance(address owner,address spender) view returns (uint256)"];
          const c = new ethers.Contract(usdc, abi, walletProvider);
          const raw = await c.allowance(owner, relayer);
          const formatted = ethers.formatUnits(raw, 6);
          allowanceOut.textContent = `${formatted} (raw=${raw.toString()})`;
        } catch (e) {
          allowanceOut.textContent = "读取失败: " + String(e);
        }
      }

      async function approveUsdc() {
        try {
          if (!signer) {
            allowanceOut.textContent = "请先连接钱包";
            return;
          }
          const usdc = usdcAddressEl.value.trim();
          const relayer = relayerAddressEl.value.trim();
          const limit = approveLimitEl.value.trim();
          if (!usdc || !relayer || !limit) {
            allowanceOut.textContent = "请填写 USDC 地址、Relayer 地址、限额";
            return;
          }
          const abi = ["function approve(address spender,uint256 amount) returns (bool)"];
          const c = new ethers.Contract(usdc, abi, signer);
          const amount = ethers.parseUnits(String(limit), 6);
          const tx = await c.approve(relayer, amount);
          allowanceOut.textContent = "已提交 approve: " + tx.hash;
          await tx.wait();
          allowanceOut.textContent = "approve 已确认: " + tx.hash;
          await refreshAllowance();
        } catch (e) {
          allowanceOut.textContent = "approve 失败: " + String(e);
        }
      }

      btnConnectWallet.addEventListener("click", connectWallet);
      btnSwitchChain.addEventListener("click", switchToArcTestnet);
      btnApprove.addEventListener("click", approveUsdc);
      btnRefreshAllowance.addEventListener("click", refreshAllowance);

      loadPublicConfig();
    </script>
  </body>
</html>


